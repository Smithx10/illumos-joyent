 _ _ _                                                                
(_) | |_   _ _ __ ___   ___  ___    ___  _ __     __ _ _ __ _ __ ___  
| | | | | | | '_ ` _ \ / _ \/ __|  / _ \| '_ \   / _` | '__| '_ ` _ \ 
| | | | |_| | | | | | | (_) \__ \ | (_) | | | | | (_| | |  | | | | | |
|_|_|_|\__,_|_| |_| |_|\___/|___/  \___/|_| |_|  \__,_|_|  |_| |_| |_|


Welcome brave fool. Don't Panic! The writer of this README is an even bigger
fool than you could be (even if old Ben wonders if those who follow fools are
more foolish).

So here's where you get started building illumos on ARM.

Step 1) You need to get a build environment set up.

Fun way:

Using a normal i386 on i386 build:
cd usr/src
dmake setup
cd cmd/sgs
dmake install

mkdir -p /opt/arm64tc/lib/amd64 /opt/arm64tc/usr/bin/amd64
cd /opt/arm64tc/lib/
ln -s amd64 64
cd ../usr/bin
ln -s amd64 64

Then from your proto area, install the following:
 o /usr/bin/ld
 o /usr/bin/amd64/ld
 o /lib/libld.so.4
 o /lib/amd64/libld.so.4
 o /lib/liblddbg.so.4
 o /lib/amd64/liblddb.so.4
 o /lib/libelf.so.1
 o /lib/amd64/libelf.so.1

Now you have yourself a cross linker!

Next, you'll want to build an aarch64 version of binutils, allowing yout to
build an aarch64 compatible gcc. Install this to /opt/arm64tc/ as well.

In the future, someone should set up an illumos-extra to do this (like we did
for the arm32 gate...)

You'll also need a cpp built, and installed to /opt/arm64tc/
 I took the one built from the arm illumos-extra...

Step 2) Set up illumos.sh

In a fresh workspace, you're going to want to set up your illumos.sh with the
following:

# Enable GCC 4 default
export __GNUC="";
export CW_NO_SHADOW=1
export MACH=arm;
export NATIVE_MACH=i386;
 
# Re-set all this MACH-based crud
REF_PROTO_LIST=$PARENT_WS/usr/src/proto_list_${MACH}; export REF_PROTO_LIST
ROOT="$CODEMGR_WS/proto/root_${MACH}"; export ROOT
PARENT_ROOT=$PARENT_WS/proto/root_$MACH; export PARENT_ROOT
PKGARCHIVE="${CODEMGR_WS}/packages/${MACH}/nightly"; export PKGARCHIVE
unset GCC_ROOT GNU_ROOT CW_GCC_DIR
export i386_GCC_ROOT=/opt/gcc/4.4.4
export arm_GCC_ROOT=/opt/arm64tc/usr
export i386_GNU_ROOT=/usr/sfw
export arm_GNU_ROOT=/opt/arm64tc/usr/gnu

#
# XXX our gcc isn't called ./usr/bin/gcc fix it up via CW env vars for now.
#
export CW_arm_GCC=/opt/arm64tc/usr/bin/aarch64-none-elf-gcc #(the gcc you built)

#
# XXX We need to set CPP to our specific cpp, not the generic /usr/ccs/lib/cpp
# as that's rather, well, x86.
#
export CPP=/opt/arm64tc/usr/lib/cpp
export AW_CPP=/opt/arm64tc/usr/lib/cpp
export LD_ALTEXEC=/opt/arm64tc/usr/bin/ld


Step 3) Start your build engines

Once you've done that, you're doing to need to need to use the *new* bldenv to
get started building. For the first time you can go ahead and do something like: 

cd usr/src
ksh93 ./tools/scripts/bldenv.sh ../../illumos.sh

This is really just a bit of a bootstrapping weirdness. Once that's done you can
go ahead and continue on.

As a part of this you should see an important two lines:

Cross-building enabled
Targeting arm on i386

If you don't, stop. illumos.sh is not configured correctly.


Once you have that you can get going. Start off with a resounding:

dmake setup

Following this, you can build the kernel as far as we have it for ARM

cd uts; dmake install

You now have a lovely unix, unix.bin and boot_archive in qv/unix/debug64
 (qemu virt board). We use unix.bin (binary format) so qemu recognizes us as a
 linux kernel, and passes us boot parameters. This is probably something that
 could be fixed in the future via a qemu patch.

Step 4) Boot

Now that you have the gate built, you can try to boot the kernel.  This is
where things diverge between qemu and the Raspberry Pi.

Booting qemu is very easy:

qemu-system-aarch64 -m 1024 -smp 2 -cpu cortex-a57 -M virt -nographic \
	-kernel unix.bin \
	-initrd boot_archive \
	-append 'kernel /platform/qv/kernel/unix -Bconsole=uart'
